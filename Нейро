// Возвращает массив длины (inputsCount + 1), где последний элемент — bias (порог).
public static double[] GenerateNeuronWeights(int inputsCount, Random rnd, bool enforceZeroMean = true, bool enforceUnitStd = true)
{
    int n = inputsCount + 1; // +1 для bias
    double[] w = new double[n];

    // Генерация нормальных N(0,1) с помощью Box-Muller
    for (int i = 0; i < n; i += 2)
    {
        double u1, u2;
        do { u1 = rnd.NextDouble(); } while (u1 <= double.Epsilon); // избегаем 0
        u2 = rnd.NextDouble();
        double r = Math.Sqrt(-2.0 * Math.Log(u1));
        double theta = 2.0 * Math.PI * u2;
        double z0 = r * Math.Cos(theta);
        double z1 = r * Math.Sin(theta);
        w[i] = z0;
        if (i + 1 < n) w[i + 1] = z1;
    }

    if (enforceZeroMean || enforceUnitStd)
    {
        // среднее по весам (включая bias)
        double mean = 0;
        for (int i = 0; i < n; ++i) mean += w[i];
        mean /= n;

        if (enforceZeroMean)
        {
            for (int i = 0; i < n; ++i) w[i] -= mean;
        }

        if (enforceUnitStd)
        {
            // вычислим выборочное стандартное отклонение
            double sumSq = 0;
            for (int i = 0; i < n; ++i)
            {
                double d = w[i]; // уже центрированы, если enforceZeroMean=true
                sumSq += d * d;
            }
            double variance = sumSq / n; // можно / (n-1) для несмещенной оценки, но для нормирования /n тоже ок
            double sd = Math.Sqrt(Math.Max(variance, 1e-12)); // защита от нуля
            if (Math.Abs(sd - 1.0) > 1e-12)
            {
                for (int i = 0; i < n; ++i) w[i] /= sd;
            }
        }
    }

    return w;
}
